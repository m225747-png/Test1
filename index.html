<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典魂斗羅 - 復刻版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; touch-action: none; }
        canvas { display: block; background: linear-gradient(#111, #224); margin: 0 auto; }
        .ui-layer { position: fixed; top: 10px; left: 10px; color: #fff; z-index: 10; font-weight: bold; }
        .controls { position: fixed; bottom: 20px; left: 0; right: 0; display: flex; justify-content: space-around; pointer-events: auto; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(2, 60px); gap: 5px; }
        .action-btns { display: flex; gap: 15px; align-items: flex-end; }
        .btn { width: 60px; height: 60px; background: rgba(255,255,255,0.2); border: 2px solid #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #fff; user-select: none; }
        #btnFire { background: rgba(255,0,0,0.5); width: 80px; height: 80px; border-color: #f00; }
        #btnJump { background: rgba(0,255,0,0.3); width: 70px; height: 70px; }
    </style>
</head>
<body>

<div class="ui-layer">
    REST 3 | SCORE: <span id="score">0</span>
</div>

<canvas id="gameCanvas"></canvas>

<div class="controls">
    <div class="d-pad">
        <div style="grid-column: 2;" class="btn" id="btnUp">↑</div>
        <div style="grid-column: 1; grid-row: 2;" class="btn" id="btnLeft">←</div>
        <div style="grid-column: 2; grid-row: 2;" class="btn" id="btnDown">↓</div>
        <div style="grid-column: 3; grid-row: 2;" class="btn" id="btnRight">→</div>
    </div>
    <div class="action-btns">
        <div class="btn" id="btnJump">B</div>
        <div class="btn" id="btnFire">A</div>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = 400;

let player = {
    x: 50, y: 300, w: 30, h: 50, dy: 0, 
    speed: 4, jumping: false, dir: 1, 
    aim: 'right', hp: 3, bullets: [], inv: 0
};

let platforms = [
    {x: 0, y: 350, w: 2000, h: 50}, // 地面
    {x: 300, y: 250, w: 200, h: 10},
    {x: 600, y: 250, w: 200, h: 10},
    {x: 450, y: 150, w: 200, h: 10}
];

let enemies = [];
let score = 0;
let cameraX = 0;
let keys = {};

// 事件監聽
const bind = (id, key) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
};
bind('btnUp', 'ArrowUp'); bind('btnDown', 'ArrowDown');
bind('btnLeft', 'ArrowLeft'); bind('btnRight', 'ArrowRight');
bind('btnJump', 'Space'); bind('btnFire', 'KeyF');

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

function fire() {
    let vx = 0, vy = 0;
    if (keys['ArrowUp']) vy = -1;
    if (keys['ArrowDown']) vy = 1;
    if (keys['ArrowLeft']) vx = -1;
    if (keys['ArrowRight']) vx = 1;
    
    if (vx === 0 && vy === 0) vx = player.dir;
    
    player.bullets.push({
        x: player.x + 15, y: player.y + 20,
        vx: vx * 8, vy: vy * 8
    });
}

let fireCooldown = 0;

function update() {
    // 玩家移動
    if (keys['ArrowRight']) { player.x += player.speed; player.dir = 1; }
    if (keys['ArrowLeft'] && player.x > cameraX) { player.x -= player.speed; player.dir = -1; }
    
    // 跳躍邏輯
    if (keys['Space'] && !player.jumping) {
        player.dy = -15;
        player.jumping = true;
    }
    
    player.dy += 0.8; // 重力
    player.y += player.dy;
    
    // 碰撞平台
    let onPlatform = false;
    platforms.forEach(p => {
        if (player.dy > 0 && player.x + 20 > p.x && player.x < p.x + p.w && 
            player.y + 50 > p.y && player.y + 50 < p.y + 20) {
            player.y = p.y - 50;
            player.dy = 0;
            player.jumping = false;
            onPlatform = true;
        }
    });

    cameraX = Math.max(cameraX, player.x - 100);

    // 射擊計時器
    if (keys['KeyF'] && fireCooldown <= 0) {
        fire();
        fireCooldown = 15;
    }
    if (fireCooldown > 0) fireCooldown--;

    // 子彈移動
    player.bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy;
        if (Math.abs(b.x - player.x) > 600) player.bullets.splice(i, 1);
    });

    // 敵人邏輯
    if (Math.random() < 0.02) {
        enemies.push({x: cameraX + canvas.width, y: 300, speed: -3});
    }

    enemies.forEach((en, i) => {
        en.x += en.speed;
        // 子彈打敵人
        player.bullets.forEach((b, bi) => {
            if (b.x > en.x && b.x < en.x + 30 && b.y > en.y && b.y < en.y + 50) {
                enemies.splice(i, 1);
                player.bullets.splice(bi, 1);
                score += 100;
            }
        });
        // 敵人撞玩家
        if (en.x < player.x + 20 && en.x + 30 > player.x && en.y < player.y + 50 && en.y + 50 > player.y) {
            if (player.inv <= 0) {
                player.hp--;
                player.inv = 60;
                if (player.hp <= 0) { alert("GAME OVER"); location.reload(); }
            }
        }
    });

    if (player.inv > 0) player.inv--;
    document.getElementById('score').innerText = score;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-cameraX, 0);

    // 畫平台
    ctx.fillStyle = "#5c3c10";
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

    // 畫子彈
    ctx.fillStyle = "#fff";
    player.bullets.forEach(b => ctx.beginPath() || ctx.arc(b.x, b.y, 4, 0, 7) || ctx.fill());

    // 畫主角 (簡化火柴人)
    if (player.inv % 10 < 5) {
        ctx.fillStyle = "#0af";
        ctx.fillRect(player.x, player.y, player.w, player.h);
        // 槍管
        ctx.fillStyle = "#fff";
        let gx = player.dir === 1 ? 25 : -10;
        ctx.fillRect(player.x + gx, player.y + 15, 15, 5);
    }

    // 畫敵人
    ctx.fillStyle = "#f00";
    enemies.forEach(en => ctx.fillRect(en.x, en.y, 30, 50));

    ctx.restore();
    update();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
